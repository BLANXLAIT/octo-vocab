# This file contains the fastlane.tools configuration
# You can find the documentation at https://docs.fastlane.tools
# For a list of all available actions, check out https://docs.fastlane.tools/actions
# For a list of all available plugins, check out https://docs.fastlane.tools/plugins/available-plugins
#
# Privacy Policy URL for App Store Connect: https://blanxlait.github.io/octo-vocab/privacy-policy.html

# Uncomment the line if you want fastlane to automatically update itself
# update_fastlane

require 'json'

# =============================================================================
# ENVIRONMENT CONFIGURATION
# =============================================================================

# Using system environment variables (from .zshrc)
UI.message "üìã Using system environment variables from shell configuration"

# Environment configuration helper - Official Fastlane method
def get_app_store_api_key
  # Priority 1: .p8 file in secure location (local development - official recommended method)
  p8_key_path = File.expand_path("~/.appstoreconnect/private/AuthKey_XGFA878VQB.p8")
  
  if File.exist?(p8_key_path)
    UI.message "üîë Using App Store Connect API Key from secure location (official method)"
    return app_store_connect_api_key(
      key_id: "XGFA878VQB",
      issuer_id: "69a6de83-1bd1-47e3-e053-5b8c7c11a4d1",
      key_filepath: p8_key_path
    )
  end
  
  # Priority 2: Environment variables (CI/CD - official supported method)
  if ENV["APP_STORE_CONNECT_API_KEY_CONTENT"] && ENV["APP_STORE_CONNECT_API_KEY_ID"] && ENV["APP_STORE_CONNECT_ISSUER_ID"]
    UI.message "üîë Using App Store Connect API Key from environment variables (CI/CD)"
    return app_store_connect_api_key(
      key_id: ENV["APP_STORE_CONNECT_API_KEY_ID"],
      issuer_id: ENV["APP_STORE_CONNECT_ISSUER_ID"],
      key_content: ENV["APP_STORE_CONNECT_API_KEY_CONTENT"],
      duration: 1200,
      in_house: false
    )
  end
  
  UI.user_error!("‚ùå No valid App Store Connect API Key found.\n\nLocal: Place AuthKey_XGFA878VQB.p8 in ~/.appstoreconnect/private/ directory\nCI/CD: Set APP_STORE_CONNECT_API_KEY_CONTENT, APP_STORE_CONNECT_API_KEY_ID, APP_STORE_CONNECT_ISSUER_ID")
end

# Validate required environment variables
def validate_environment!
  # Always required
  always_required = ["FASTLANE_TEAM_ID", "MATCH_PASSWORD", "MATCH_GIT_URL", "MATCH_CERTS_PAT"]
  missing_vars = always_required.select { |var| ENV[var].nil? || ENV[var].empty? }
  
  unless missing_vars.empty?
    UI.user_error!("‚ùå Missing required environment variables: #{missing_vars.join(', ')}")
  end
  
  # API key validation is handled by get_app_store_api_key method
  # Local: JSON file, CI/CD: environment variables
  UI.success "‚úÖ Using official Fastlane API key methods"
end

# =============================================================================

default_platform(:ios)

platform :ios do
  before_all do
    # Validate environment configuration
    validate_environment!
    
    UI.message "üîë Using App Store Connect API authentication"
    UI.message "üè¢ Team ID: #{ENV['FASTLANE_TEAM_ID']}"
    UI.message "üì± App ID: #{ENV['APP_IDENTIFIER'] || 'com.blanxlait.octo-vocab'}"
  end

  desc "Create bundle identifier on Apple Developer Portal"
  lane :create_bundle_id do
    UI.message "üì± Creating bundle identifier on Apple Developer Portal..."
    
    begin
      # Try to create bundle identifier using spaceship
      Spaceship::Portal.login
      Spaceship::Portal.select_team
      
      bundle_id = Spaceship::Portal::BundleId.find(ENV["APP_IDENTIFIER"] || "com.blanxlait.octo-vocab")
      if bundle_id
        UI.success "Bundle ID already exists!"
      else
        bundle_id = Spaceship::Portal::BundleId.create(
          bundle_id: ENV["APP_IDENTIFIER"] || "com.blanxlait.octo-vocab",
          name: ENV["APP_NAME"] || "Octo Vocab"
        )
        UI.success "‚úÖ Bundle ID created successfully!"
      end
    rescue => e
      UI.error "Failed to create bundle ID: #{e.message}"
      # Fall back to produce
      UI.message "Trying alternative approach..."
      
      # Create using environment variables instead
      produce(
        app_identifier: ENV["APP_IDENTIFIER"] || "com.blanxlait.octo-vocab",
        app_name: ENV["APP_NAME"] || "Octo Vocab",
        team_id: ENV["FASTLANE_TEAM_ID"],
        skip_itc: true,
        skip_devcenter: false
      )
    end
    
    UI.success "‚úÖ Bundle ID setup completed!"
  end

  desc "Create app on App Store Connect and Developer Portal"
  lane :create_app do
    UI.message "üöÄ Creating app on App Store Connect..."
    
    produce(
      app_identifier: ENV["APP_IDENTIFIER"] || "com.blanxlait.octo-vocab",
      app_name: ENV["APP_NAME"] || "Octo Vocab",
      language: "English",
      app_version: "1.0",
      sku: "OCTOVOCAB2024",
      team_id: ENV["FASTLANE_TEAM_ID"],
      itc_team_id: ENV["FASTLANE_ITC_TEAM_ID"],
      platforms: ["ios"],
      skip_devcenter: false,
      skip_itc: false
    )
    
    UI.success "‚úÖ App created successfully!"
  end

  desc "Test App Store Connect API authentication"
  lane :test_auth do
    UI.message "üîç Testing App Store Connect API authentication..."
    
    # Debug: Show what environment variables are available
    UI.message "üîç Environment Debug Info:"
    UI.message "   APP_STORE_CONNECT_API_KEY_ID: #{ENV['APP_STORE_CONNECT_API_KEY_ID'] ? 'SET' : 'MISSING'}"
    UI.message "   APP_STORE_CONNECT_ISSUER_ID: #{ENV['APP_STORE_CONNECT_ISSUER_ID'] ? 'SET' : 'MISSING'}"
    UI.message "   APP_STORE_CONNECT_API_KEY_CONTENT: #{ENV['APP_STORE_CONNECT_API_KEY_CONTENT'] ? "SET (#{ENV['APP_STORE_CONNECT_API_KEY_CONTENT'].length} chars)" : 'MISSING'}"
    UI.message "   FASTLANE_TEAM_ID: #{ENV['FASTLANE_TEAM_ID'] ? 'SET' : 'MISSING'}"
    
    begin
      # Get API key using the same method as successful upload
      api_key = get_app_store_api_key
      UI.message "üîë API Key object type: #{api_key.class}"
      
      # Test with a simple pilot action that we know works
      # Use the latest_testflight_build_number which makes a simple API call
      build_number = latest_testflight_build_number(
        api_key: api_key,
        app_identifier: ENV["APP_IDENTIFIER"] || "com.blanxlait.octo-vocab"
      )
      
      UI.success "‚úÖ API Authentication successful!"
      UI.message "   Latest TestFlight build number: #{build_number}"
      
    rescue => e
      UI.error "‚ùå API Authentication failed: #{e.message}"
      UI.error "   Full error: #{e.inspect}"
      UI.user_error!("‚ùå App Store Connect API authentication failed. Check your API key configuration.")
    end
  end

  desc "Sync certificates and provisioning profiles using match"
  lane :sync_certificates do
    UI.message "üì± Syncing certificates and provisioning profiles using match..."
    
    # Configure Git authentication for private repository access
    if ENV["MATCH_CERTS_PAT"]
      # Use Personal Access Token for private repository authentication
      git_url = ENV["MATCH_GIT_URL"].gsub('https://github.com/', "https://#{ENV["MATCH_CERTS_PAT"]}@github.com/")
      UI.message "üîê Using Personal Access Token for private repository access"
    else
      git_url = ENV["MATCH_GIT_URL"]
      UI.message "‚ö†Ô∏è  No PAT found - using basic Git URL (may fail for private repos)"
    end
    
    # Configure App Store Connect API key for match
    api_key = get_app_store_api_key
    
    # Use match for certificate and provisioning profile management
    # Allow creation of new profiles if MATCH_READONLY is not set to "true"
    match_params = {
      type: "appstore",
      app_identifier: ENV["APP_IDENTIFIER"] || "com.blanxlait.octo-vocab",
      git_url: git_url,
      git_branch: ENV["MATCH_GIT_BRANCH"] || "main",
      readonly: ENV["MATCH_READONLY"] == "true",  # Respect MATCH_READONLY environment variable
      force_for_new_devices: true
    }
    
    # Add API key
    match_params[:api_key] = api_key
    
    match(match_params)
    
    UI.success "‚úÖ Certificates and provisioning profiles synced successfully!"
  end

  desc "Build the iOS app"
  lane :build do |options|
    UI.message "üèóÔ∏è Building iOS app..."
    
    # Configure Flutter for release build  
    UI.message "üê¶ Configuring Flutter for release..."
    # Build iOS app using existing pub cache (no re-download) with timeout and retry logic
    retry_count = 0
    begin
      Timeout::timeout(600) do # 10 minute timeout
        sh("cd .. && flutter build ios --config-only --release --no-pub")
      end
    rescue Timeout::Error
      UI.user_error!("Flutter build timed out after 10 minutes")
    rescue => e
      retry_count += 1
      if retry_count < 3
        UI.important("Flutter build failed, retrying (#{retry_count}/3)...")
        UI.important("Error: #{e.message}")
        sleep(5) # Brief pause before retry
        retry
      else
        UI.user_error!("Flutter build failed after 3 attempts: #{e.message}")
      end
    end
    
    # Increment build number
    increment_build_number(
      xcodeproj: "Runner.xcodeproj"
    )
    
    # Build the app using match-managed certificates
    UI.message "üì± Building with match-managed certificates..."
    
    # Build the app
    build_app(
      workspace: "Runner.xcworkspace",
      scheme: "Runner",
      configuration: "Release",
      export_method: "app-store",
      # Clean build
      clean: true,
      # Flutter specific
      archive_path: "./build/Runner.xcarchive",
      output_directory: "./build",
      # Debugging and performance tracking
      verbose: true,
      build_timing_summary: true,
      analyze_build_time: true,
      # Let match handle the signing automatically
      export_options: {
        method: "app-store",
        teamID: ENV["FASTLANE_TEAM_ID"],
        provisioningProfiles: {
          (ENV["APP_IDENTIFIER"] || "com.blanxlait.octo-vocab") => "match AppStore #{ENV['APP_IDENTIFIER'] || 'com.blanxlait.octo-vocab'}"
        }
      }
    )
    
    UI.success "‚úÖ App built successfully!"
  end

  desc "Build app for distribution"
  lane :build_only do
    UI.message "üß™ Building app for distribution..."
    
    # Build the app
    build
    
    UI.success "‚úÖ App built successfully! IPA available at: ./build/Runner.ipa"
  end

  desc "Deploy to TestFlight for beta testing"
  lane :beta do |options|
    UI.message "üß™ Deploying to TestFlight..."
    
    # Build the app
    build
    
    # Upload to TestFlight using environment-based API key
    api_key = get_app_store_api_key
    
    # Generate dynamic changelog if not provided
    changelog = options[:changelog] || ENV["CHANGELOG"] || begin
      # Try to get changelog from git commits
      if system("git --version > /dev/null 2>&1")
        recent_commits = sh("git log --oneline -5 --pretty=format:'‚Ä¢ %s'", log: false).strip
        "Recent updates:\n\n#{recent_commits}\n\nPrivacy-first vocabulary learning app for students."
      else
        "Privacy-first vocabulary learning app for students.\n\nFeatures:\n‚Ä¢ ACTFL-aligned leveling system\n‚Ä¢ Offline-first architecture\n‚Ä¢ No data collection\n‚Ä¢ Latin and Spanish vocabulary\n‚Ä¢ Adaptive mobile/tablet UI"
      end
    rescue
      "Privacy-first vocabulary learning app for students.\n\nFeatures:\n‚Ä¢ ACTFL-aligned leveling system\n‚Ä¢ Offline-first architecture\n‚Ä¢ No data collection\n‚Ä¢ Latin and Spanish vocabulary\n‚Ä¢ Adaptive mobile/tablet UI"
    end
    
    # Upload to TestFlight
    upload_to_testflight(
      api_key: api_key,
      app_identifier: ENV["APP_IDENTIFIER"] || "com.blanxlait.octo-vocab",
      skip_waiting_for_build_processing: ENV["CI"] ? true : false, # Skip processing in CI for faster builds
      skip_submission: true,
      # Beta app information
      changelog: changelog,
      # Beta testing configuration
      distribute_external: false,
      notify_external_testers: false,
      # Compliance
      uses_non_exempt_encryption: false
    )
    
    UI.success "üéâ App uploaded to TestFlight! Check App Store Connect for processing status."
    
    if ENV["CI"]
      UI.message "‚ö° Running in CI - build processing will continue in background"
      UI.message "   Check App Store Connect for build processing progress"
    end
  end

  desc "Deploy to App Store for production release"
  lane :release do
    UI.message "üöÄ Deploying to App Store..."
    
    # Build the app
    build
    
    # Configure App Store Connect API for release
    api_key = get_app_store_api_key
    
    # Upload to App Store with metadata from fastlane/metadata/en-US/
    upload_to_app_store(
      api_key: api_key,
      app_identifier: ENV["APP_IDENTIFIER"] || "com.blanxlait.octo-vocab",
      force: true,
      reject_if_possible: true,
      skip_metadata: false,
      skip_screenshots: true,
      skip_binary_upload: false,
      # App Store submission
      submit_for_review: false, # Manual review submission for safety
      automatic_release: false,
      run_precheck_before_submit: false, # Skip precheck to avoid API key limitations
      # Privacy and compliance
      submission_information: {
        add_id_info_uses_idfa: false,
        add_id_info_serves_ads: false,
        add_id_info_tracks_action: false,
        add_id_info_tracks_install: false,
        content_rights_has_rights: true,
        content_rights_contains_third_party_content: false,
        export_compliance_platform: 'ios',
        export_compliance_compliance_required: false,
        export_compliance_encryption_updated: false,
        export_compliance_app_type: nil,
        export_compliance_uses_encryption: false
      }
    )
    
    UI.success "üéâ App uploaded to App Store! Go to App Store Connect to submit for review."
  end

  desc "Generate App Store screenshots"
  lane :screenshots do
    UI.message "üì∏ Generating App Store screenshots..."
    
    # Generate screenshots using UI tests
    capture_screenshots
    
    UI.success "‚úÖ Screenshots generated successfully!"
  end

  desc "Generate and upload App Store screenshots"
  lane :upload_screenshots do
    UI.message "üì∏ Generating and uploading App Store screenshots..."
    
    # Configure App Store Connect API
    api_key = get_app_store_api_key
    
    # Generate screenshots using UI tests
    capture_screenshots
    
    # Upload screenshots to App Store Connect
    deliver(
      api_key: api_key,
      app_identifier: ENV["APP_IDENTIFIER"] || "com.blanxlait.octo-vocab",
      skip_binary_upload: true,
      skip_metadata: true,
      skip_screenshots: false,
      overwrite_screenshots: true,
      force: true,
      run_precheck_before_submit: false  # Skip precheck to avoid API key limitations
    )
    
    UI.success "‚úÖ Screenshots generated and uploaded to App Store Connect!"
  end

  desc "Upload existing screenshots to App Store Connect"
  lane :upload_existing_screenshots do
    UI.message "üì∏ Uploading existing screenshots to App Store Connect..."
    
    # Configure App Store Connect API
    api_key = get_app_store_api_key
    
    # Upload existing screenshots to App Store Connect (no generation)
    deliver(
      api_key: api_key,
      app_identifier: ENV["APP_IDENTIFIER"] || "com.blanxlait.octo-vocab",
      skip_binary_upload: true,
      skip_metadata: true,
      skip_screenshots: false,
      overwrite_screenshots: true,
      force: true,
      run_precheck_before_submit: false  # Skip precheck to avoid API key limitations
    )
    
    UI.success "‚úÖ Existing screenshots uploaded to App Store Connect!"
  end

  desc "Update App Store metadata and screenshots"
  lane :update_metadata do
    UI.message "üìù Updating App Store Connect metadata..."
    
    # Configure App Store Connect API for metadata upload
    api_key = get_app_store_api_key
    
    # Upload metadata to App Store Connect
    deliver(
      api_key: api_key,
      app_identifier: ENV["APP_IDENTIFIER"] || "com.blanxlait.octo-vocab",
      skip_binary_upload: true,
      skip_screenshots: true,
      force: true,
      # Metadata will be read from fastlane/metadata/en-US/ files
      overwrite_screenshots: false,
      run_precheck_before_submit: false  # Skip precheck to avoid API key limitations
    )
    
    UI.success "‚úÖ App Store metadata updated successfully!"
  end

  desc "Generate screenshots and update metadata"
  lane :update_store_assets do
    UI.message "üé® Updating all App Store assets..."
    
    # Generate fresh screenshots
    screenshots
    
    # Configure App Store Connect API
    api_key = get_app_store_api_key
    
    # Upload both metadata and screenshots
    deliver(
      api_key: api_key,
      app_identifier: ENV["APP_IDENTIFIER"] || "com.blanxlait.octo-vocab",
      skip_binary_upload: true,
      skip_screenshots: false, # Include screenshots
      force: true,
      overwrite_screenshots: true,
      run_precheck_before_submit: false  # Skip precheck to avoid API key limitations
    )
    
    UI.success "‚úÖ All App Store assets updated successfully!"
  end

  desc "Setup: Create app and sync certificates (run once)"
  lane :setup do
    UI.message "‚öôÔ∏è Setting up Octo Vocab for deployment..."
    
    create_app
    sync_certificates
    
    UI.success "üéâ Setup complete! You can now run 'fastlane beta' or 'fastlane release'"
  end

  after_all do |lane|
    # This block is called, only if the executed lane was successful
    UI.success "‚úÖ Lane #{lane} completed successfully!"
  end


  error do |lane, exception|
    UI.error "‚ùå Lane #{lane} failed with error: #{exception.message}"
    # Add error handling/notifications here if needed
  end
end
